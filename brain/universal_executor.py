"""
Universal Task Executor for Shadow AI
Executes any task generated by the Universal Processor
"""
import logging
import time
import json
import os
import traceback
from typing import Dict, Any, List, Optional, Callable
from dataclasses import dataclass
from datetime import datetime

import pyautogui
import subprocess
import webbrowser
from pathlib import Path

from brain.universal_processor import UniversalTask, TaskStep, TaskComplexity
from control.desktop import desktop_controller
from control.browser import get_browser_controller, close_browser
from control.documents import document_controller
from control.advanced_vision import AdvancedVision
from control.intelligent_browser import IntelligentBrowser
from input.voice_input import speak_response
from utils.confirm import confirm_action, confirm_sensitive_action

@dataclass
class ExecutionResult:
    """Result of task execution"""
    success: bool
    step_results: List[Dict[str, Any]]
    error_message: Optional[str] = None
    execution_time: float = 0.0
    warnings: List[str] = None

class UniversalExecutor:
    """
    Universal Task Executor that can execute any computer task
    """
    
    def __init__(self):
        self.setup_components()
        self.execution_history = []
        self.active_processes = {}
        self.context_cache = {}
        
    def setup_components(self):
        """Initialize all execution components"""
        try:
            self.advanced_vision = AdvancedVision()
            logging.info("Advanced Vision initialized")
        except Exception as e:
            logging.warning(f"Advanced Vision not available: {e}")
            self.advanced_vision = None
            
        try:
            self.intelligent_browser = IntelligentBrowser()
            logging.info("Intelligent Browser initialized")
        except Exception as e:
            logging.warning(f"Intelligent Browser not available: {e}")
            self.intelligent_browser = None
            
        # Action handlers mapping
        self.action_handlers = {
            # Desktop actions
            "open_notepad": self._open_notepad,
            "open_text_editor": self._open_text_editor,
            "open_notepad_and_type": self._open_notepad_and_type,
            "open_notepad_and_write_article": self._open_notepad_and_write_article,
            "open_notepad_create_file_write_article": self._open_notepad_create_file_write_article,
            "type_text": self._type_text,
            "type_content": self._type_content,  # Added missing handler
            "click_at": self._click_at,
            "take_screenshot": self._take_screenshot,
            "open_application": self._open_application,
            
            # Document actions
            "create_document": self._create_document,
            "create_article": self._create_article,
            "create_leave_letter": self._create_leave_letter,
            "save_document": self._save_document,
            "open_word": self._open_word,
            
            # Web actions
            "open_browser": self._open_browser,
            "navigate_to": self._navigate_to,
            "search_web": self._search_web,
            "click_element": self._click_element,
            "fill_form": self._fill_form,
            
            # File actions
            "save_file": self._save_file,
            "open_file": self._open_file,
            "copy_file": self._copy_file,
            "move_file": self._move_file,
            "delete_file": self._delete_file,
            
            # Email actions
            "open_email": self._open_email,
            "compose_email": self._compose_email,
            "send_email": self._send_email,
            
            # System actions
            "run_command": self._run_command,
            "open_settings": self._open_settings,
            "adjust_volume": self._adjust_volume,
            
            # Content generation
            "generate_article_content": self._generate_article_content,
            "generate_letter_content": self._generate_letter_content,
            "create_content": self._create_content,
            
            # Analysis actions
            "analyze_command": self._analyze_command,
            "analyze_screen": self._analyze_screen,
            
            # Universal fallback
            "execute_universal": self._execute_universal
        }

    def execute_task(self, task: UniversalTask, context: Dict[str, Any] = None) -> ExecutionResult:
        """
        Execute a universal task
        
        Args:
            task: UniversalTask to execute
            context: Optional execution context
            
        Returns:
            ExecutionResult: Result of execution
        """
        start_time = time.time()
        step_results = []
        warnings = []
        
        logging.info(f"Executing task: {task.description}")
        
        try:
            # Pre-execution validation
            if not self._validate_execution_environment(task):
                return ExecutionResult(
                    success=False,
                    step_results=[],
                    error_message="Execution environment validation failed",
                    execution_time=time.time() - start_time
                )
            
            # Check if user confirmation is required
            if task.requires_user_confirmation or task.risk_level == "high":
                if not self._get_user_confirmation(task):
                    return ExecutionResult(
                        success=False,
                        step_results=[],
                        error_message="User did not confirm task execution",
                        execution_time=time.time() - start_time
                    )
            
            # Execute each step
            for i, step in enumerate(task.steps):
                logging.info(f"Executing step {step.step_number}: {step.action}")
                
                try:
                    step_result = self._execute_step(step, context)
                    step_results.append(step_result)
                    
                    if not step_result.get("success", False):
                        error_msg = step_result.get("error", "Unknown error")
                        logging.error(f"Step {step.step_number} failed: {error_msg}")
                        
                        # Handle error based on step configuration
                        if step.error_handling == "abort":
                            return ExecutionResult(
                                success=False,
                                step_results=step_results,
                                error_message=f"Step {step.step_number} failed: {error_msg}",
                                execution_time=time.time() - start_time,
                                warnings=warnings
                            )
                        elif step.error_handling == "retry":
                            # Retry the step once
                            logging.info(f"Retrying step {step.step_number}")
                            step_result = self._execute_step(step, context)
                            step_results[-1] = step_result
                        else:
                            # Continue with warning
                            warnings.append(f"Step {step.step_number} failed but continuing: {error_msg}")
                    
                    # Update context with step results
                    if context is None:
                        context = {}
                    context.update(step_result.get("context_updates", {}))
                    
                    # Brief pause between steps
                    time.sleep(0.5)
                    
                except Exception as e:
                    error_msg = f"Exception in step {step.step_number}: {str(e)}"
                    logging.error(error_msg)
                    logging.error(traceback.format_exc())
                    
                    step_results.append({
                        "step_number": step.step_number,
                        "success": False,
                        "error": error_msg
                    })
                    
                    if step.error_handling == "abort":
                        return ExecutionResult(
                            success=False,
                            step_results=step_results,
                            error_message=error_msg,
                            execution_time=time.time() - start_time,
                            warnings=warnings
                        )
                    else:
                        warnings.append(error_msg)
            
            # Check success criteria
            success = self._check_success_criteria(task, step_results, context)
            
            execution_time = time.time() - start_time
            
            # Log execution result
            result = ExecutionResult(
                success=success,
                step_results=step_results,
                execution_time=execution_time,
                warnings=warnings if warnings else None
            )
            
            self.execution_history.append({
                "task": task,
                "result": result,
                "timestamp": datetime.now()
            })
            
            # Provide user feedback
            if success:
                speak_response("Task completed successfully!")
                logging.info(f"Task completed successfully in {execution_time:.2f} seconds")
            else:
                speak_response("Task completed with some issues. Please check the results.")
                logging.warning(f"Task completed with warnings in {execution_time:.2f} seconds")
            
            return result
            
        except Exception as e:
            error_msg = f"Fatal error executing task: {str(e)}"
            logging.error(error_msg)
            logging.error(traceback.format_exc())
            
            return ExecutionResult(
                success=False,
                step_results=step_results,
                error_message=error_msg,
                execution_time=time.time() - start_time,
                warnings=warnings
            )

    def _execute_step(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute a single task step"""
        
        # Get the appropriate handler
        handler = self.action_handlers.get(step.action, self._execute_universal)
        
        try:
            # Set timeout for step execution
            result = self._execute_with_timeout(handler, step, context, step.timeout_seconds)
            
            if result is None:
                result = {"success": False, "error": "Handler returned None"}
            
            result["step_number"] = step.step_number
            result["action"] = step.action
            result["application"] = step.application
            
            return result
            
        except TimeoutError:
            return {
                "step_number": step.step_number,
                "action": step.action,
                "success": False,
                "error": f"Step timed out after {step.timeout_seconds} seconds"
            }
        except Exception as e:
            return {
                "step_number": step.step_number,
                "action": step.action,
                "success": False,
                "error": f"Exception: {str(e)}"
            }

    def _execute_with_timeout(self, handler: Callable, step: TaskStep, context: Dict[str, Any], timeout: int) -> Dict[str, Any]:
        """Execute handler with timeout"""
        # For now, execute directly - could add proper timeout handling later
        return handler(step, context)

    def _validate_execution_environment(self, task: UniversalTask) -> bool:
        """Validate that the environment is ready for task execution"""
        
        # Check context requirements
        for requirement in task.context_requirements:
            if requirement == "internet_access":
                try:
                    import requests
                    requests.get("https://www.google.com", timeout=5)
                except:
                    logging.error("Internet access required but not available")
                    return False
            
            elif requirement == "text_editor_available":
                # Check if notepad is available
                if not self._is_application_available("notepad.exe"):
                    logging.error("Text editor required but not available")
                    return False
            
            elif requirement == "file_system_access":
                # Check write permissions
                try:
                    test_file = Path.home() / "test_write.tmp"
                    test_file.touch()
                    test_file.unlink()
                except:
                    logging.error("File system write access required but not available")
                    return False
        
        return True

    def _is_application_available(self, app_name: str) -> bool:
        """Check if an application is available"""
        try:
            # For notepad, check if it exists in Windows
            if app_name == "notepad.exe":
                # Use where command to check if notepad exists
                result = subprocess.run(["where", "notepad"], capture_output=True, timeout=5)
                return result.returncode == 0
            
            # For other apps, try to check using where command
            app_base = app_name.replace(".exe", "")
            result = subprocess.run(["where", app_base], capture_output=True, timeout=5)
            return result.returncode == 0
        except:
            # Fallback - assume common Windows apps are available
            if app_name in ["notepad.exe", "calc.exe", "mspaint.exe"]:
                return True
            return False

    def _get_user_confirmation(self, task: UniversalTask) -> bool:
        """Get user confirmation for task execution"""
        
        confirmation_message = f"""
Task: {task.description}
Complexity: {task.complexity.value}
Risk Level: {task.risk_level}
Estimated Duration: {task.estimated_duration} seconds
Steps: {len(task.steps)}

Do you want to proceed with this task?
"""
        
        if task.risk_level == "high":
            return confirm_sensitive_action(confirmation_message)
        else:
            return confirm_action(confirmation_message)

    def _check_success_criteria(self, task: UniversalTask, step_results: List[Dict[str, Any]], context: Dict[str, Any]) -> bool:
        """Check if task success criteria are met"""
        
        # Basic check: all steps succeeded
        all_steps_success = all(result.get("success", False) for result in step_results)
        
        if not all_steps_success:
            return False
        
        # Task-specific success criteria
        if task.success_criteria == "Task completed":
            return True
        
        # Add more specific criteria checking here
        return True

    # Desktop Action Handlers
    def _open_notepad(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Open Notepad application"""
        try:
            subprocess.Popen(["notepad.exe"])
            time.sleep(2)  # Wait for notepad to open
            return {"success": True, "message": "Notepad opened successfully"}
        except Exception as e:
            return {"success": False, "error": f"Failed to open Notepad: {str(e)}"}

    def _open_text_editor(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Open default text editor"""
        return self._open_notepad(step, context)

    def _open_notepad_and_type(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Open Notepad and type text"""
        try:
            # Open notepad first
            result = self._open_notepad(step, context)
            if not result["success"]:
                return result
            
            # Type the text
            text = step.parameters.get("text", "")
            if text:
                time.sleep(1)  # Additional wait for notepad to be ready
                pyautogui.typewrite(text)
                return {"success": True, "message": f"Typed text in Notepad: {text[:50]}..."}
            else:
                return {"success": False, "error": "No text provided to type"}
                
        except Exception as e:
            return {"success": False, "error": f"Failed to open Notepad and type: {str(e)}"}

    def _open_notepad_and_write_article(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Open Notepad and write an article"""
        try:
            # Open notepad first
            result = self._open_notepad(step, context)
            if not result["success"]:
                return result
            
            # Generate article content
            topic = step.parameters.get("topic", "AI")
            filename = step.parameters.get("filename", "new.txt")
            article_content = self._generate_article_about_topic(topic)
            
            # Wait for notepad to be ready
            time.sleep(2)
            
            # Type the article
            pyautogui.typewrite(article_content, interval=0.01)
            
            # Save the file with the specified name
            time.sleep(1)
            
            # Use Ctrl+S to save
            pyautogui.hotkey('ctrl', 's')
            time.sleep(1)
            
            # Type the filename
            pyautogui.typewrite(filename, interval=0.05)
            time.sleep(0.5)
            
            # Press Enter to save
            pyautogui.press('enter')
            time.sleep(1)
            
            return {
                "success": True, 
                "message": f"Article about {topic} written and saved as {filename}",
                "content_length": len(article_content),
                "filename": filename
            }
            
        except Exception as e:
            return {"success": False, "error": f"Failed to write article: {str(e)}"}

    def _open_notepad_create_file_write_article(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Complete notepad task: open notepad, create file, name it, write article about AI"""
        try:
            # Extract parameters
            filename = step.parameters.get("filename", "new.txt")
            topic = step.parameters.get("topic", "AI")
            
            logging.info(f"Starting complete notepad task: create {filename} with {topic} article")
            
            # Step 1: Open notepad
            subprocess.Popen(["notepad.exe"])
            time.sleep(3)  # Wait for notepad to fully load
            
            # Step 2: Generate and type the article content
            article_content = self._generate_comprehensive_ai_article()
            
            logging.info(f"Typing article content ({len(article_content)} characters)")
            pyautogui.typewrite(article_content, interval=0.01)
            
            # Step 3: Save the file with specified name
            time.sleep(1)
            logging.info(f"Saving file as {filename}")
            
            # Use Ctrl+S to open save dialog
            pyautogui.hotkey('ctrl', 's')
            time.sleep(2)  # Wait for save dialog
            
            # Type the filename (clear any existing text first)
            pyautogui.hotkey('ctrl', 'a')  # Select all text in filename field
            time.sleep(0.5)
            pyautogui.typewrite(filename, interval=0.05)
            time.sleep(1)
            
            # Press Enter to save
            pyautogui.press('enter')
            time.sleep(2)  # Wait for save to complete
            
            return {
                "success": True,
                "message": f"Successfully created {filename} with AI article ({len(article_content)} characters)",
                "filename": filename,
                "topic": topic,
                "content_length": len(article_content)
            }
            
        except Exception as e:
            logging.error(f"Error in complete notepad task: {e}")
            return {"success": False, "error": f"Failed to complete notepad task: {str(e)}"}

    def _generate_comprehensive_ai_article(self) -> str:
        """Generate a comprehensive article about AI"""
        article = """Understanding Artificial Intelligence: A Comprehensive Guide

Introduction
Artificial Intelligence (AI) has emerged as one of the most transformative technologies of the 21st century. From science fiction concepts to practical applications that enhance our daily lives, AI represents a paradigm shift in how we approach problem-solving and automation.

What is Artificial Intelligence?
Artificial Intelligence refers to the simulation of human intelligence in machines that are programmed to think and learn like humans. These systems can perform tasks that typically require human intelligence, such as visual perception, speech recognition, decision-making, and language translation.

Types of AI
AI can be broadly categorized into several types:

1. Narrow AI (Weak AI): Designed to perform specific tasks, such as voice assistants, recommendation systems, and image recognition software.

2. General AI (Strong AI): Hypothetical AI that would possess the ability to understand, learn, and apply intelligence across a wide range of tasks, similar to human cognitive abilities.

3. Superintelligent AI: A theoretical form of AI that would surpass human intelligence in all aspects.

Key Components of AI Systems
- Machine Learning: Algorithms that enable systems to learn from data without explicit programming
- Natural Language Processing: The ability to understand and generate human language
- Computer Vision: The capability to interpret and analyze visual information
- Neural Networks: Computing systems inspired by biological neural networks
- Deep Learning: Advanced machine learning using multi-layered neural networks

Current Applications
AI is already integrated into numerous aspects of modern life:
- Healthcare: Disease diagnosis, drug discovery, and personalized treatment plans
- Transportation: Autonomous vehicles and traffic optimization
- Finance: Fraud detection, algorithmic trading, and risk assessment
- Entertainment: Content recommendation and game AI
- Education: Personalized learning platforms and intelligent tutoring systems

Benefits and Advantages
- Increased efficiency and productivity
- Enhanced decision-making capabilities
- Automation of repetitive tasks
- 24/7 availability without fatigue
- Processing vast amounts of data quickly
- Improved accuracy in various applications

Challenges and Concerns
- Job displacement and economic impact
- Privacy and data security issues
- Ethical considerations and bias in AI systems
- Need for regulation and governance
- Technical limitations and reliability concerns
- The potential for misuse or malicious applications

Future Prospects
The future of AI holds immense promise. We can expect continued advancement in:
- More sophisticated natural language understanding
- Improved human-AI collaboration
- Enhanced AI safety and reliability
- Broader integration across industries
- Development of more energy-efficient AI systems
- Progress toward artificial general intelligence

Ethical Considerations
As AI becomes more prevalent, it's crucial to address ethical concerns:
- Ensuring fairness and avoiding discrimination
- Maintaining transparency in AI decision-making
- Protecting user privacy and data rights
- Establishing accountability for AI actions
- Promoting beneficial AI development

Conclusion
Artificial Intelligence represents both an incredible opportunity and a significant responsibility. As we continue to develop and deploy AI systems, it's essential to balance innovation with ethical considerations, ensuring that AI serves humanity's best interests while addressing potential risks and challenges.

The journey of AI is just beginning, and its impact on society will depend on how thoughtfully we approach its development and implementation. By fostering responsible AI research and deployment, we can harness its power to create a better future for all.

---
Article generated by Shadow AI
Date: """ + datetime.now().strftime("%Y-%m-%d %H:%M:%S") + """
Word count: Approximately 500 words
"""
        return article

    def _type_text(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Type text at current cursor position"""
        try:
            text = step.parameters.get("text", "")
            if text:
                pyautogui.typewrite(text)
                return {"success": True, "message": f"Text typed: {text[:50]}..."}
            else:
                return {"success": False, "error": "No text provided to type"}
        except Exception as e:
            return {"success": False, "error": f"Failed to type text: {str(e)}"}

    def _type_content(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Type content (supports template replacement from context)"""
        try:
            text = step.parameters.get("text", "")
            
            # Handle template replacement
            if "{{generated_content}}" in text and context:
                generated_content = context.get("generated_content", "")
                text = text.replace("{{generated_content}}", generated_content)
            
            # Handle other template variables
            if "{{" in text and context:
                for key, value in context.items():
                    text = text.replace(f"{{{{{key}}}}}", str(value))
            
            if text:
                # Add a small delay to ensure the target application is ready
                time.sleep(0.5)
                pyautogui.typewrite(text, interval=0.01)  # Slightly slower typing
                return {"success": True, "message": f"Content typed: {text[:100]}..."}
            else:
                return {"success": False, "error": "No content provided to type"}
        except Exception as e:
            return {"success": False, "error": f"Failed to type content: {str(e)}"}

    def _click_at(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Click at specific coordinates"""
        try:
            x = step.parameters.get("x", 0)
            y = step.parameters.get("y", 0)
            pyautogui.click(x, y)
            return {"success": True, "message": f"Clicked at ({x}, {y})"}
        except Exception as e:
            return {"success": False, "error": f"Failed to click: {str(e)}"}

    def _take_screenshot(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Take a screenshot"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"screenshot_{timestamp}.png"
            filepath = Path.home() / "Desktop" / filename
            
            screenshot = pyautogui.screenshot()
            screenshot.save(filepath)
            
            return {
                "success": True, 
                "message": f"Screenshot saved as {filename}",
                "filepath": str(filepath)
            }
        except Exception as e:
            return {"success": False, "error": f"Failed to take screenshot: {str(e)}"}

    def _open_application(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Open any application"""
        try:
            app_name = step.parameters.get("app_name", "")
            if not app_name:
                return {"success": False, "error": "No application name provided"}
            
            subprocess.Popen([app_name])
            time.sleep(2)
            return {"success": True, "message": f"Opened {app_name}"}
        except Exception as e:
            return {"success": False, "error": f"Failed to open {app_name}: {str(e)}"}

    # Document Action Handlers
    def _create_document(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Create a document"""
        try:
            content = step.parameters.get("content", "")
            filename = step.parameters.get("filename", "document.txt")
            format_type = step.parameters.get("format", "txt")
            
            # For now, create as text file
            filepath = Path.home() / "Desktop" / filename
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            
            return {
                "success": True,
                "message": f"Document created: {filename}",
                "filepath": str(filepath)
            }
        except Exception as e:
            return {"success": False, "error": f"Failed to create document: {str(e)}"}

    def _create_article(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Create an article"""
        try:
            topic = step.parameters.get("topic", "general topic")
            open_in_notepad = step.parameters.get("open_in_notepad", False)
            
            # Generate article content
            content = self._generate_article_about_topic(topic)
            
            if open_in_notepad:
                # Open in notepad
                result = self._open_notepad(step, context)
                if result["success"]:
                    time.sleep(1)
                    pyautogui.typewrite(content)
                    return {"success": True, "message": f"Article about {topic} created in Notepad"}
                else:
                    return result
            else:
                # Save as file
                filename = f"article_{topic.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d')}.txt"
                filepath = Path.home() / "Desktop" / filename
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(content)
                return {"success": True, "message": f"Article saved as {filename}"}
                
        except Exception as e:
            return {"success": False, "error": f"Failed to create article: {str(e)}"}

    def _create_leave_letter(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Create a leave letter"""
        try:
            reason = step.parameters.get("reason", "personal reasons")
            content = self._generate_leave_letter(reason)
            
            # Open notepad and type the letter
            result = self._open_notepad(step, context)
            if result["success"]:
                time.sleep(1)
                pyautogui.typewrite(content)
                return {"success": True, "message": "Leave letter created in Notepad"}
            else:
                return result
                
        except Exception as e:
            return {"success": False, "error": f"Failed to create leave letter: {str(e)}"}

    def _save_document(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Save current document"""
        try:
            # Use Ctrl+S to save
            pyautogui.hotkey('ctrl', 's')
            time.sleep(1)
            
            # If filename provided, type it
            filename = step.parameters.get("filename", "")
            if filename:
                pyautogui.typewrite(filename)
                time.sleep(0.5)
                pyautogui.press('enter')
            
            return {"success": True, "message": "Document saved"}
        except Exception as e:
            return {"success": False, "error": f"Failed to save document: {str(e)}"}

    def _open_word(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Open Microsoft Word"""
        try:
            subprocess.Popen(["winword.exe"])
            time.sleep(3)
            return {"success": True, "message": "Microsoft Word opened"}
        except Exception as e:
            # Fallback to notepad
            return self._open_notepad(step, context)

    # Web Action Handlers
    def _open_browser(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Open web browser"""
        try:
            url = step.parameters.get("url", "https://www.google.com")
            webbrowser.open(url)
            time.sleep(3)
            return {"success": True, "message": f"Browser opened with {url}"}
        except Exception as e:
            return {"success": False, "error": f"Failed to open browser: {str(e)}"}

    def _navigate_to(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Navigate to URL"""
        try:
            url = step.parameters.get("url", "")
            if not url:
                return {"success": False, "error": "No URL provided"}
            
            webbrowser.open(url)
            return {"success": True, "message": f"Navigated to {url}"}
        except Exception as e:
            return {"success": False, "error": f"Failed to navigate: {str(e)}"}

    def _search_web(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Search the web"""
        try:
            query = step.parameters.get("query", "")
            if not query:
                return {"success": False, "error": "No search query provided"}
            
            search_url = f"https://www.google.com/search?q={query.replace(' ', '+')}"
            webbrowser.open(search_url)
            return {"success": True, "message": f"Searched for: {query}"}
        except Exception as e:
            return {"success": False, "error": f"Failed to search: {str(e)}"}

    def _click_element(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Click web element"""
        # This would require advanced web automation
        return {"success": False, "error": "Web element clicking not implemented yet"}

    def _fill_form(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Fill web form"""
        # This would require advanced web automation
        return {"success": False, "error": "Web form filling not implemented yet"}

    # File Action Handlers
    def _save_file(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Save file"""
        try:
            content = step.parameters.get("content", "")
            filepath = step.parameters.get("filepath", "")
            
            if not filepath:
                filename = step.parameters.get("filename", "file.txt")
                filepath = Path.home() / "Desktop" / filename
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            
            return {"success": True, "message": f"File saved: {filepath}"}
        except Exception as e:
            return {"success": False, "error": f"Failed to save file: {str(e)}"}

    def _open_file(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Open file"""
        try:
            filepath = step.parameters.get("filepath", "")
            if not filepath:
                return {"success": False, "error": "No filepath provided"}
            
            os.startfile(filepath)
            return {"success": True, "message": f"File opened: {filepath}"}
        except Exception as e:
            return {"success": False, "error": f"Failed to open file: {str(e)}"}

    def _copy_file(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Copy file"""
        # Implementation for file copying
        return {"success": False, "error": "File copying not implemented yet"}

    def _move_file(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Move file"""
        # Implementation for file moving
        return {"success": False, "error": "File moving not implemented yet"}

    def _delete_file(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Delete file"""
        # Implementation for file deletion
        return {"success": False, "error": "File deletion not implemented yet"}

    # Email Action Handlers
    def _open_email(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Open email client"""
        try:
            # Try to open Outlook
            subprocess.Popen(["outlook.exe"])
            time.sleep(3)
            return {"success": True, "message": "Email client opened"}
        except Exception as e:
            return {"success": False, "error": f"Failed to open email client: {str(e)}"}

    def _compose_email(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Compose email"""
        # Implementation for email composition
        return {"success": False, "error": "Email composition not implemented yet"}

    def _send_email(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Send email"""
        # Implementation for sending email
        return {"success": False, "error": "Email sending not implemented yet"}

    # System Action Handlers
    def _run_command(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Run system command"""
        try:
            command = step.parameters.get("command", "")
            if not command:
                return {"success": False, "error": "No command provided"}
            
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            return {
                "success": result.returncode == 0,
                "message": f"Command executed: {command}",
                "output": result.stdout,
                "error": result.stderr if result.returncode != 0 else None
            }
        except Exception as e:
            return {"success": False, "error": f"Failed to run command: {str(e)}"}

    def _open_settings(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Open system settings"""
        try:
            subprocess.Popen(["ms-settings:"])
            return {"success": True, "message": "System settings opened"}
        except Exception as e:
            return {"success": False, "error": f"Failed to open settings: {str(e)}"}

    def _adjust_volume(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Adjust system volume"""
        # Implementation for volume adjustment
        return {"success": False, "error": "Volume adjustment not implemented yet"}

    # Content Generation Handlers
    def _generate_article_content(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Generate article content"""
        try:
            topic = step.parameters.get("topic", "general topic")
            length = step.parameters.get("length", "medium")
            
            content = self._generate_article_about_topic(topic, length)
            
            return {
                "success": True,
                "message": f"Article content generated about {topic}",
                "content": content,
                "context_updates": {"generated_content": content}
            }
        except Exception as e:
            return {"success": False, "error": f"Failed to generate content: {str(e)}"}

    def _generate_letter_content(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Generate letter content"""
        try:
            letter_type = step.parameters.get("type", "formal")
            reason = step.parameters.get("reason", "personal reasons")
            
            content = self._generate_leave_letter(reason)
            
            return {
                "success": True,
                "message": f"Letter content generated",
                "content": content,
                "context_updates": {"generated_content": content}
            }
        except Exception as e:
            return {"success": False, "error": f"Failed to generate letter: {str(e)}"}

    def _create_content(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Create content based on type"""
        try:
            content_type = step.parameters.get("type", "document")
            command = step.parameters.get("command", "")
            
            if content_type == "article":
                return self._generate_article_content(step, context)
            elif content_type == "letter":
                return self._generate_letter_content(step, context)
            else:
                # Generic content generation
                content = f"Generated content for: {command}\n\nThis is placeholder content that would be generated based on the user's request."
                return {
                    "success": True,
                    "message": f"Content generated for {content_type}",
                    "content": content,
                    "context_updates": {"generated_content": content}
                }
        except Exception as e:
            return {"success": False, "error": f"Failed to create content: {str(e)}"}

    # Analysis Handlers
    def _analyze_command(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Analyze unknown command"""
        command = step.parameters.get("command", "")
        return {
            "success": True,
            "message": f"Command analyzed: {command}",
            "analysis": "This appears to be a command that requires custom handling"
        }

    def _analyze_screen(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Analyze current screen"""
        if self.advanced_vision:
            # Use advanced vision for screen analysis
            return {"success": False, "error": "Screen analysis not fully implemented"}
        else:
            return {"success": False, "error": "Advanced vision not available"}

    # Universal Fallback Handler
    def _execute_universal(self, step: TaskStep, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Universal fallback handler for unknown actions"""
        action = step.action
        
        # Try to map unknown actions to known ones
        if "type" in action.lower():
            # Map any typing action to type_content
            return self._type_content(step, context)
        elif "click" in action.lower():
            return self._click_at(step, context)
        elif "open" in action.lower():
            if "notepad" in action.lower() or "text" in action.lower():
                # Check if it's the complex notepad task
                if ("create" in action.lower() and "file" in action.lower() and 
                    ("article" in action.lower() or "write" in action.lower())):
                    return self._open_notepad_create_file_write_article(step, context)
                else:
                    return self._open_notepad(step, context)
            elif "browser" in action.lower():
                return self._open_browser(step, context)
            else:
                return self._open_application(step, context)
        elif "create" in action.lower():
            if "document" in action.lower() or "article" in action.lower():
                return self._create_document(step, context)
            else:
                return self._create_content(step, context)
        elif "save" in action.lower():
            return self._save_file(step, context)
        elif "generate" in action.lower():
            return self._generate_article_content(step, context)
        else:
            # Try to execute as system command
            try:
                logging.warning(f"Unknown action '{action}', attempting system execution")
                return self._run_command(step, context)
            except:
                return {
                    "success": False,
                    "error": f"Unknown action: {action}",
                    "message": f"Action '{action}' is not implemented. Available actions: {list(self.action_handlers.keys())}"
                }

    # Helper Methods
    def _generate_article_about_topic(self, topic: str, length: str = "medium") -> str:
        """Generate article content about a topic"""
        
        if length == "short":
            length_desc = "brief"
            word_count = "200-300 words"
        elif length == "long":
            length_desc = "comprehensive"
            word_count = "800-1000 words"
        else:
            length_desc = "informative"
            word_count = "400-600 words"
        
        article = f"""Title: Understanding {topic.title()}

Introduction:
{topic.title()} is an important subject that deserves our attention and understanding. In this {length_desc} article, we will explore the key aspects of {topic} and its significance in our modern world.

Main Content:
{topic.title()} encompasses various elements that make it both fascinating and relevant. Whether you're a beginner or someone with some knowledge, understanding {topic} can provide valuable insights.

Key Points:
• {topic.title()} has evolved significantly over time
• Modern applications of {topic} are diverse and impactful
• Understanding {topic} can benefit both personal and professional development
• Future trends in {topic} show promising developments

Examples and Applications:
In practical terms, {topic} can be observed in various contexts. Real-world applications demonstrate the versatility and importance of {topic} in solving contemporary challenges.

Conclusion:
{topic.title()} remains a vital area of interest that continues to shape our understanding and approach to related fields. As we move forward, the importance of {topic} will likely continue to grow.

---
Word Count: Approximately {word_count}
Generated by Shadow AI on {datetime.now().strftime('%Y-%m-%d')}
"""
        return article

    def _generate_leave_letter(self, reason: str = "personal reasons") -> str:
        """Generate a leave letter"""
        today = datetime.now().strftime("%B %d, %Y")
        
        letter = f"""Date: {today}

To,
The Manager/Supervisor
[Company/Organization Name]

Subject: Application for Leave

Dear Sir/Madam,

I am writing to formally request leave from work due to {reason}. I would be grateful if you could grant me leave for the necessary period.

I have ensured that all my current responsibilities are up to date, and I have made arrangements for any urgent matters that may arise during my absence. I will be available via email/phone if there are any critical issues that require my immediate attention.

I apologize for any inconvenience this may cause and appreciate your understanding in this matter. I look forward to returning to work and resuming my duties.

Thank you for your consideration.

Yours sincerely,
[Your Name]
[Your Position]
[Contact Information]

---
Generated by Shadow AI on {today}
"""
        return letter

# Global instance
universal_executor = UniversalExecutor()

def execute_universal_task(task: UniversalTask, context: Dict[str, Any] = None) -> ExecutionResult:
    """Main entry point for universal task execution"""
    return universal_executor.execute_task(task, context)
